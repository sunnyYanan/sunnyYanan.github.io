<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HUAWEIYANG</title>
    <description>sunny小亚男的博客</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 20 Oct 2015 15:15:18 +0800</pubDate>
    <lastBuildDate>Tue, 20 Oct 2015 15:15:18 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>ios自动化测试入门之脚本编写</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;写在前面&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;编写脚本&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;编辑工具&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#or-&quot; id=&quot;markdown-toc-or-&quot;&gt;模拟器 or 真机&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;元素访问&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;手势动作&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;高级交互&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;脚本运行&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;题外话&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;  在上一篇中，我们介绍了ios ui automation的脚本录制回放功能，可以看到该方法的使用非常简单，它可以帮助我们了解instrument中脚本运行的原理以及基本的脚本语法，但是在实际使用过程中，我们无法仅仅利用录制回放功能来简单录制我们需要执行的过程然后直接运行脚本从而实现自动化，这是因为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;元素定位&lt;/strong&gt;：在使用脚本录制功能时，对某元素的访问会直接使用名称，如&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;
target.frontMostApp().mainWindow().scrollViews()[0].collectionViews()[0].cells()[&quot;         [买2个送1个][凤全] 加粗实心铁条 创意心型多用途挂钩 1个顶7个可承重50斤以上 高温烤漆耐用10年以上&quot;].tap();
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; 但是，这种与元素特有属性－名字相结合的写法无法应对应用的内容变动，当app中元素变化时，脚本将因为无法访问到元素而执行错误。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;意外警告及弹窗&lt;/strong&gt;：在应用的实际使用过程中，常常会弹出各种各种的信息获取或者消息提示弹窗，而这些弹窗在脚本录制过程中，是无法覆盖完全的。而且可能发生的一种情况就是，录制过程中发生了弹窗，但是脚本再执行时不一定会遇到的弹窗，如只有首次安装才会遇到的位置获取弹窗等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;兼容性问题&lt;/strong&gt;：在不同的操作系统中，app的实现方式会有细微的差别，元素的层级结构和整个窗口的结构安排也会不同，这些都需要脚本的微调来适应兼容性问题。这些问题仅仅通过脚本录制回放功能是无法解决的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt; 因此，实际使用过程中，脚本需要手工编写。下面我们介绍自动化脚本的编写以及执行过程。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;编写脚本&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;编辑工具&lt;/h3&gt;

&lt;p&gt; 我们可以直接在instrument automation中的编辑页面进行自动化脚本的编辑，但是这种情况下代码格式需要手工控制，十分不友好。因此，我们可以选用sublime text3来编写js脚本，这也是前端人员使用最多的js编辑工具。&lt;/p&gt;

&lt;h3 id=&quot;or-&quot;&gt;模拟器 or 真机&lt;/h3&gt;
&lt;p&gt; 在iOS UI automation自动化测试入门之录制回放功能中，我们已经介绍了automation基本的使用流程，模拟器或者真机的区别在于target中机型的选择，当电脑连接真机后，target中便可以选择该设备，&lt;strong&gt;需要注意&lt;/strong&gt;的一点是，在ios8中，如果想要执行自动化脚本，想要打开真机设备的ui automation的开关，其设置路径为：&lt;/p&gt;

&lt;p&gt;设置－开发者－enable ui automation。&lt;/p&gt;

&lt;p&gt;脚本运行中如果发生莫名其妙的错误，一定要首先检查这项开关的设置是否已经打开，不然会浪费很多功夫。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;元素访问&lt;/h3&gt;
&lt;p&gt; 每一个可以访问的UIKit控件都可以用一个javascript对象来描述，也就是一个UIAElement。我们可以使用以下两种方式来访问元素。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;logElementTree()&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt; 使用target.logElementTree()的方法可以得到当前页面下所有元素层级。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Accessibility inspector&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt; 在模拟器中，可以通过路径：设置－general-accessibility打开accessibility inspector来查看当前页面中元素的属性，如元素的label，name，rect。&lt;/p&gt;

&lt;p&gt; 查询到元素之后，就可以通过元素的名称、序号等属性来访问对应的元素。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;手势动作&lt;/h3&gt;

&lt;p&gt; 通过对页面中元素执行用户动作，就可以模拟真实的用户操作。一些操作的方法如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;点击&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;对具体的元素执行点击：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;UIATarget.localTarget().frontMostApp().mainWindow().buttons()[1].tap();&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;对窗口某位置进行点击：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;UIATarget.localTarget().frontMostApp().mainWindow().tap({x:100,y:30});&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;双击方法：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;doubleTap();&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;缩放&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;UIATarget.localTarget().pinchOpenFromToForDuration({x:20, y:200},{x:300, y:200},2);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;UIATarget.localTarget().pinchCloseFromToForDuration({x:20, y:200}, {x:300, y:200},2);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;拖拽或滑动&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;UIATarget.localTarget().dragFromToForDuration({x:160, y:200},{x:160,y:400},1);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;UIATarget.localTarget().flickFromTo({x:160, y:200},{x:160, y:400});&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-5&quot;&gt;高级交互&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;处理预期或者非预期的提示框（alert）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;UIATarget.onAlert = function onAlert(alert){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var title = alert.name(); 

UIALogger.logWarning(&quot;Alert with title ’&quot; + title + &quot;’ encountered!&quot;); 

return false; // use default handler 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;该方法返回false，会帮助我们自动销毁alertview的窗口。&lt;/p&gt;

&lt;p&gt;UIATarget.onAlert = function onAlert(alert) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var title = alert.name(); 

UIALogger.logWarning(&quot;Alert with title ’&quot; + title + &quot;’ encountered!&quot;); 

if (title == &quot;Add Something&quot;) { 

    alert.buttons()[&quot;Add&quot;].tap(); 

    return true; // bypass default handler 
} 
return false; // use default handler 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt; 返回true会帮助我们处理一些我们预期会发生的alert，如获取用户位置信息。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;多任务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt; 我们可能需要测试某些后台程序，或者将程序放入后台执行来观察一些数据信息，通过以下方法就可以模拟用户点击home操作，将程序放入后台执行，并在10秒之后重新打开程序。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;UIATarget.localTarget().deactivateAppForDuration(10);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;屏幕方向&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt; 通过setDeviceOrientation()方法可以设置设备的方向，自动化脚本运行中一般不会用到。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;脚本运行&lt;/h3&gt;

&lt;p&gt; 当编辑完脚本之后，我们可以导入我们的脚本文件，然后点击target下方的红色按钮（注意此时是target下的那个红色按钮）或者win+r的方式来运行我们的脚本。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;题外话&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;当不知道如何编写脚本时，不妨使用录制回放功能来进行查看，它可以作为很好的参考。&lt;/li&gt;
  &lt;li&gt;执行自动化脚本时，使用target.delay(3)方法可以帮助我们观测执行情况，并处理很多网络延迟，页面加载等时间问题。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 20 Oct 2015 04:27:05 +0800</pubDate>
        <link>/2015/10/20/ios-uiautomation2/</link>
        <guid isPermaLink="true">/2015/10/20/ios-uiautomation2/</guid>
        
        
        <category>ios-ui-automation</category>
        
      </item>
    
      <item>
        <title>ios自动化测试入门之录制回放功能</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#instrument&quot; id=&quot;markdown-toc-instrument&quot;&gt;打开instrument&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;创建模版&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#target&quot; id=&quot;markdown-toc-target&quot;&gt;选择工程target&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;点击录制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;instrument&quot;&gt;打开instrument&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;点击标题栏product下的profile或者windows+i打开instrument&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/ios-ui-automation-01-01.png&quot; alt=&quot;Alt test&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;创建模版&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;点击“automation”创建模版&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/ios-ui-automation-01-02.png&quot; alt=&quot;Alt test&quot; /&gt;&lt;/p&gt;

&lt;p&gt; 打开之后，就已经自动创建了一个js脚本文件，如果想要新建一个脚本文件或者导入一个已有的脚本文件，可以通过以下入口进行创建或者导入&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ios-ui-automation-01-03.png&quot; alt=&quot;Alt test&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;target&quot;&gt;选择工程target&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;可以选择在模拟器上也可以选择在真机上运行，选择对应的机型即可。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/ios-ui-automation-01-04.png&quot; alt=&quot;Alt test&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;点击录制&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;点击脚本文件下方的红色按钮开始录制脚本，此时在模拟器或者真机上操作即可，脚本录制结束后，点击其左侧的运行按钮即可运行录制的脚本。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/ios-ui-automation-01-05.png&quot; alt=&quot;Alt test&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 26 Jul 2015 22:06:05 +0800</pubDate>
        <link>/2015/07/26/ios-uiautomation/</link>
        <guid isPermaLink="true">/2015/07/26/ios-uiautomation/</guid>
        
        
        <category>ios-ui-automation</category>
        
      </item>
    
      <item>
        <title>Jekyll 搭建静态博客</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;搭建过程&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ruby&quot; id=&quot;markdown-toc-ruby&quot;&gt;安装Ruby&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#rubygems&quot; id=&quot;markdown-toc-rubygems&quot;&gt;安装RubyGems&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#rubygemsjekyll&quot; id=&quot;markdown-toc-rubygemsjekyll&quot;&gt;用RubyGems安装Jekyll&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;创建博客&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;后续&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;可能出现的问题&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#hitimeshitimes-loaderror&quot; id=&quot;markdown-toc-hitimeshitimes-loaderror&quot;&gt;&lt;code&gt;hitimes/hitimes (LoadError)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;一直以来都想搭建一个自己的博客，但是近半年做项目太忙，再加上教研室的网络很坑爹，所以也一直没顾得上。之前用过 WordPress 托管在免费的京东云擎上，但是速度太慢。在知乎上看到一些相关的内容，于是选择了在github上用jekyll搭建博客。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;搭建过程&lt;/h2&gt;

&lt;p&gt;在jekyll的官网上 &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;http://jekyllrb.com/&lt;/a&gt; 其实已经说得比较明白了，我在这里还是简单的说一下吧。我用的是Windows系统。  &lt;br /&gt;
主要环节有：安装Ruby，安装RubyGems，安装jekyll，安装代码高亮插件，安装node.js&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;ruby&quot;&gt;安装Ruby&lt;/h3&gt;

&lt;p&gt;ruby官网下载安装：&lt;a href=&quot;https://www.ruby-lang.org/en/downloads/&quot;&gt;https://www.ruby-lang.org/en/downloads/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装完成后配置环境变量&lt;/p&gt;

&lt;p&gt;在命令提示符中，得到ruby版本号，如下图，即安装成功
&lt;img src=&quot;/css/pics/ruby-v.png&quot; alt=&quot;ruby-v&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;rubygems&quot;&gt;安装RubyGems&lt;/h3&gt;

&lt;p&gt;官网下载 &lt;a href=&quot;http://rubygems.org/pages/download&quot;&gt;http://rubygems.org/pages/download&lt;/a&gt; rubygems-2.4.5.zip&lt;/p&gt;

&lt;p&gt;cd到RubyGems目录&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/css/pics/ruby-gems.png&quot; alt=&quot;ruby-gems&quot; /&gt;&lt;/p&gt;

&lt;p&gt;执行安装&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/css/pics/ruby-gems-setup.png&quot; alt=&quot;ruby-gems-setup&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;rubygemsjekyll&quot;&gt;用RubyGems安装Jekyll&lt;/h3&gt;

&lt;p&gt;执行下面的语句安装&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/css/pics/jekyll-setup.png&quot; alt=&quot;jekyll-setup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;安装结束画面&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/css/pics/jekyll-setup-finish.png&quot; alt=&quot;jekyll-setup-finish&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至此jekyll就已经安装完毕了，后续就是个性化的自己设定了。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;创建博客&lt;/h3&gt;

&lt;p&gt;在d盘新建一个工作区jekyllWorkspace&lt;/p&gt;

&lt;p&gt;cd到jekyllWorkspace&lt;/p&gt;

&lt;p&gt;执行jekyll new name创建新的工作区&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/css/pics/jekyllWorkSpace.png&quot; alt=&quot;jekyllWorkSpace&quot; /&gt;&lt;/p&gt;

&lt;p&gt;文件结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/css/pics/jekyllFiles.png&quot; alt=&quot;jekyllFiles&quot; /&gt;&lt;/p&gt;

&lt;p&gt;cd到博客文件夹，开启服务器&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/css/pics/serve.png&quot; alt=&quot;serve&quot; /&gt;&lt;/p&gt;

&lt;p&gt;watch为了检测文件夹内的变化，即修改后不需要重新启动jekyll&lt;/p&gt;

&lt;p&gt;我的环境下启动报错(你的可能没有)，再安装yajl-ruby和rouge&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/css/pics/yajl.png&quot; alt=&quot;yajl&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再次启动服务器成功&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/css/pics/serve-sucess.png&quot; alt=&quot;serve-sucess&quot; /&gt;&lt;/p&gt;

&lt;p&gt;访问 http://localhost:4000/&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/css/pics/browser.png&quot; alt=&quot;browser&quot; /&gt;&lt;/p&gt;

&lt;p&gt;详细文章页面&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/css/pics/browser2.png&quot; alt=&quot;browser2&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-3&quot;&gt;后续&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;整个安装过程参考了jekyll官网，注意jekyll还有一个简体中文官网，不过比较坑（我就被坑了），有些内容没有翻译过来，有可能会走弯路，建议如果想看中文的相关资料，也要中英对照着阅读。&lt;a href=&quot;http://jekyllcn.com&quot;&gt;jekyll中文网 http://jekyllcn.com&lt;/a&gt;, &lt;a href=&quot;http://jekyllrb.com&quot;&gt;jekyll英文网 http://jekyllrb.com&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;jekyll中的css是用sass写的，当然直接在&lt;code&gt;_sass/_layout.scss&lt;/code&gt;中添加css也是可以的。&lt;/li&gt;
  &lt;li&gt;本文是用Markdown格式来写的，相关语法可参考： &lt;a href=&quot;http://wowubuntu.com/markdown/&quot;&gt;Markdown 语法说明 (简体中文版) http://wowubuntu.com/markdown/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;按照本文的说明搭建完博客后，用&lt;code&gt;github Pages&lt;/code&gt;托管就可以看到了。注意，在github上面好像不支持rouge，所以要push到github上时，我将配置文件_config.yml中的代码高亮改变为&lt;code&gt;highlighter: pygments&lt;/code&gt;就可以了&lt;/li&gt;
  &lt;li&gt;博客默认是没有评论系统的，本文的评论系统使用了多说，详细安装办法可访问&lt;a href=&quot;http://duoshuo.com/&quot;&gt;多说官网 http://duoshuo.com/&lt;/a&gt;，当然也可以使用&lt;a href=&quot;http://changyan.sohu.com/&quot;&gt;搜狐畅言 http://changyan.sohu.com/&lt;/a&gt;作为评论系统。&lt;/li&gt;
  &lt;li&gt;也可以绑定自己的域名，如果没有域名，可以在&lt;a href=&quot;http://www.godaddy.com/&quot;&gt;godaddy http://www.godaddy.com/&lt;/a&gt;上将域名放入购物车等待降价，买之。&lt;/li&gt;
  &lt;li&gt;祝各位新年快乐！&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-4&quot;&gt;可能出现的问题&lt;/h2&gt;

&lt;h3 id=&quot;hitimeshitimes-loaderror&quot;&gt;&lt;code&gt;hitimes/hitimes (LoadError)&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;错误代码：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;markdown&quot;&gt;C:/Ruby22/lib/ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in `require&#39;: cannot load such file -- hitimes/hitimes (LoadError)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;解决方法：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在stackoverflow上又一个很好的解决方法。&lt;a href=&quot;http://stackoverflow.com/questions/28985481/hitimes-require-error-when-running-jekyll-serve-on-windows-8-1&quot;&gt;hitimes require error when running jekyll serve on windows 8.1&lt;/a&gt; 虽然上面的题主问的是 win 8.1 系统下的情况，但是同样适用于 win7。下面我简单翻译一下错误原因和解决方法。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;可能是 Ruby 2.2 和 hitimes-1.2.2-x86-mingw32 中有一些 ABI 变化，少了一些相关的类库。&lt;/p&gt;

  &lt;p&gt;所以卸载 hitimes 并通过 &lt;code&gt;--platform ruby&lt;/code&gt; 重装即可。代码如下：&lt;/p&gt;

  &lt;pre&gt;&lt;code class=&quot;markdown&quot;&gt;gem uni hitimes
**Remove ALL versions**
gem ins hitimes -v 1.2.1 --platform ruby
&lt;/code&gt;&lt;/pre&gt;
  &lt;p&gt;然后将自动重新编译 hitimes 并适用于 Ruby 2.2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面是我自己的卸载和安装过程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;markdown&quot;&gt;E:\GitWorkSpace\gaohaoyang.github.io&amp;gt;gem uni hitimes

You have requested to uninstall the gem:
        hitimes-1.2.2-x86-mingw32

timers-4.0.1 depends on hitimes (&amp;gt;= 0)
If you remove this gem, these dependencies will not be met.
Continue with Uninstall? [yN]  y
Successfully uninstalled hitimes-1.2.2-x86-mingw32

E:\GitWorkSpace\gaohaoyang.github.io&amp;gt;gem ins hitimes -v 1.2.1 --platform ruby
Fetching: hitimes-1.2.1.gem (100%)
Temporarily enhancing PATH to include DevKit...
Building native extensions.  This could take a while...
Successfully installed hitimes-1.2.1
Parsing documentation for hitimes-1.2.1
Installing ri documentation for hitimes-1.2.1
Done installing documentation for hitimes after 1 seconds
1 gem installed&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于，&lt;a href=&quot;https://rubygems.org/gems/hitimes/versions/1.2.2&quot;&gt;hitimes&lt;/a&gt; 是一个快速的高效的定时器解决方案库，详情可以去官网查看。&lt;/p&gt;

</description>
        <pubDate>Mon, 16 Feb 2015 06:14:54 +0800</pubDate>
        <link>/2015/02/16/create-my-blog-with-jekyll/</link>
        <guid isPermaLink="true">/2015/02/16/create-my-blog-with-jekyll/</guid>
        
        
        <category>jekyll</category>
        
      </item>
    
      <item>
        <title>hello jekyll!</title>
        <description>&lt;p&gt;You’ll find this post in your &lt;code&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def print_hi(name)
  puts &quot;Hi, #{name}&quot;
end
print_hi(&#39;Tom&#39;)
#=&amp;gt; prints &#39;Hi, Tom&#39; to STDOUT.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://github.com/jekyll/jekyll-help&quot;&gt;Jekyll’s dedicated Help repository&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Tue, 10 Feb 2015 23:14:54 +0800</pubDate>
        <link>/2015/02/10/welcome-to-jekyll/</link>
        <guid isPermaLink="true">/2015/02/10/welcome-to-jekyll/</guid>
        
        
        <category>jekyll</category>
        
      </item>
    
  </channel>
</rss>
